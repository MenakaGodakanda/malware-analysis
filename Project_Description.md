# Malware Analysis Project - Version 1

This project provides tools for analyzing malware samples. It includes scripts for extracting IOCs and reverse engineering malware code.

## Features:

The malware analysis project you've created has several key features that allow it to effectively analyze malware samples and provide detailed reports. Here is a detailed description of these features:

1. **PE File Analysis**
- Library Used: pefile
- Purpose: Analyze Portable Executable (PE) files, which are common in Windows environments.
- Functionality:
  - Extract Indicators of Compromise (IOCs): The script extracts information about imported DLLs and functions from the PE file.
  - Report Generation: The extracted information is written to a report file, detailing the DLLs and functions used by the malware, which can be crucial for understanding its behavior and potential targets.

2. **Reverse Engineering**
- Tool Used: Radare2
- Purpose: Perform in-depth analysis of the malware's binary code to understand its functionality.
- Functionality:
  - Automated Analysis: The script runs Radare2 with a set of commands that analyze the binary, list functions, and provide detailed information about the executable.
  - Report Generation: The results of the analysis are written to a report file, which can be used for further study and understanding of the malware’s internal workings.

3. **Automated Report Generation**
- Purpose: Provide comprehensive and readable reports for each type of analysis performed.
- Functionality:
  - PE File Analysis Report: Lists imported DLLs and functions.
  - Reverse Engineering Report: Contains detailed information about the executable’s structure and functions.

4. **Modular Design**
- Scripts are modular, allowing for easy updates and addition of new analysis features.

5. **Open Source Tools**
- Utilizes widely-used open-source tools such as Radare2 and pefile.

6. **Directory Structure and Organization**
- Purpose: Maintain an organized file structure for easy access and management.
- Functionality:
  - Samples Directory: Contains malware samples to be analyzed.
  - Reports Directory: Stores the generated reports for each analysis.
  - Scripts Directory: Contains the Python scripts used for different types of analysis.

## Coding Details:

### extract_iocs.py:

This script uses `pefile` to analyze a PE (Portable Executable) file and extract indicators of compromise (IOCs) like imported DLLs and functions.

1. **Imports**: The script imports the `pefile` and `os` modules.

2. **analyze_pe Function**:
- Parameters: `file_path` (path to the PE file), `report_path` (path to save the extracted IOCs report).
- pefile.PE(file_path): Loads the PE file using `pefile`.
- with open(report_path, 'w') as report: Opens the report file for writing.
- Extract IOCs:
  - Import Directory: Iterates through `pe.DIRECTORY_ENTRY_IMPORT` to access the imported DLLs and their functions.
  - Write to Report: Writes the DLL names and function names/addresses to the report file.

3. **Paths**:
- `sample_path`: Path to the PE file to be analyzed.
- `report_path`: Path to save the extracted IOCs report.

4. **Create Directory**:
- `os.makedirs(os.path.dirname(report_path), exist_ok=True)`: Ensures the reports directory exists.

5. **Run Analysis**:
- `analyze_pe(sample_path, report_path)`: Runs the PE file analysis and writes the IOCs to the report file.

### reverse_engineer.py

This script uses Radare2 to perform reverse engineering on a given executable file. It captures the output of Radare2 and saves it to a report file.

1. **Imports**: The script imports the `os` module to run system commands and create directories.

2. **run_radare2 Function**:
- Parameters: `file_path` (path to the sample executable), `report_path` (path to save the Radare2 analysis report).
- Radare2 Command:
  - `r2 -A -q -c 'aaaa; afl; afll' {file_path}`: This command runs Radare2 in quiet mode (`-q`), analyzes the file (`-A`), and executes the commands in the quotes:
    - `aaaa`: Analyze all.
    - `afl`: List all functions.
    - `afll`: List all functions with details.
- Redirection: The output of the Radare2 command is redirected to the `report_path` file.
- os.system: Executes the Radare2 command.

3. **Paths**:
- `sample_path`: Path to the executable file to be analyzed.
- `report_path`: Path to save the analysis report.

4. **Create Directory**:
- `os.makedirs(os.path.dirname(report_path), exist_ok=True)`: Ensures the reports directory exists.

5. **Run Analysis**:
- `run_radare2(sample_path, report_path)`: Runs the Radare2 analysis and writes the output to the report file.

## Reports:

### iocs.json

This JSON object comes from the `extract_iocs.py` script that analyzes the PE file to extract useful information for malware analysis. Here is a detailed explanation of each component in the output:

1. **entry_point**
```
"entry_point": 30650
```
- Explanation: The `entry_point` value indicates the address within the PE file where execution begins when the file is loaded into memory. This address is given as an offset from the `image_base`. In this case, the entry point is at the offset `30650`. This information is crucial for understanding where the code execution starts, which is often the first step in analyzing the behavior of an executable.

2. **image_base**
```
"image_base": 4194304
```
- Explanation: The `image_base` value represents the preferred base address in memory where the PE file is loaded. In this case, the base address is `4194304` (which is `0x400000` in hexadecimal). The actual address where the entry point code is executed would be `image_base + entry_point` (i.e., `4194304 + 30650`). The image base is important for understanding the memory layout of the loaded executable.

3. **imports**
```
"imports": [
    "KERNEL32.dll",
    "USER32.dll",
    "ADVAPI32.dll",
    "MSVCRT.dll"
]
```
- Explanation: The `imports` array lists the dynamic-link libraries (DLLs) that the PE file depends on. These DLLs provide functions that the executable uses. Understanding which libraries are imported can provide insights into the capabilities and behavior of the executable. Each DLL listed here can contain various functions that the malware might call to perform its operations. For example:
  - KERNEL32.dll: Contains core Windows API functions, including system services like file operations, memory management, and process/thread operations.
  - USER32.dll: Contains functions for user interface components like windows, buttons, and message handling.
  - ADVAPI32.dll: Provides advanced API services, including security and registry services.
  - MSVCRT.dll: The Microsoft C Runtime Library, which provides standard C library functions like input/output, memory allocation, and string manipulation.

This JSON output provides a snapshot of important information about the executable. Analyzing this information helps in understanding the structure and potential behavior of the executable, which is essential in malware analysis to identify malicious actions and develop mitigation strategies.


### reverse_engineer.txt

The `reverse_engineer.txt` is a big file. Instead of explaining `reverse_engineer.txt`, here explained the output provided from running the `reverse_engineer.py` script, which uses Radare2 (r2) to perform a series of analyses on a malware sample.

1. **Analyze all flags starting with sym. and entry0 (aa)**
- Command: `aa`
- Explanation: This command performs a basic analysis of the binary, focusing on symbols and the entry point. It helps to identify and label functions, variables, and other significant symbols within the binary.

2. **Analyze imports (af@@@i)**
- Command: `afi`
- Explanation: This command analyzes the imported functions and libraries that the binary relies on. Understanding imports is crucial because it reveals which external libraries and functions the malware uses, which can give insights into its capabilities and behavior.

3. **Analyze entrypoint (af@ entry0)**
- Command: `af @ entry0`
- Explanation: This command specifically analyzes the entry point of the binary, which is where execution begins. Analyzing the entry point is important to understand the initial actions of the malware when it is executed.

4. **Analyze symbols (af@@@s)**
- Command: `afs`
- Explanation: This command analyzes all symbols in the binary. Symbols include functions, global variables, and other significant entities that are defined in the binary.

5. **Analyze all functions arguments/locals (afva@@@F)**
- Command: `afva`
- Explanation: This command analyzes the arguments and local variables of all functions. It provides information about the function parameters and local variables used, which is useful for understanding how the functions interact and manipulate data.

6. **Analyze function calls (aac)**
- Command: `aac`
- Explanation: This command analyzes all function calls within the binary. It helps to map out the control flow and understand how different functions call each other.

7. **Analyze len bytes of instructions for references (aar)**
- Command: `aar`
- Explanation: This command analyzes a specified length of bytes in the instructions to find references. It helps to identify references to data and code within the binary.

8. **Finding and parsing C++ vtables (avrr)**
- Command: `avrr`
- Explanation: This command finds and parses virtual tables (vtables) used in C++ programs. Vtables are used for dynamic dispatch in object-oriented programming, and analyzing them helps to understand the class hierarchy and virtual functions.

9. **Analyzing methods (af @@ method.*)**
- Command: `af @@ method.*`
- Explanation: This command analyzes all methods, particularly in object-oriented code. It provides details about the methods defined in the binary.

10. **Recovering local variables (afva@@@F)**
- Command: `afva`
- Explanation: This command attempts to recover local variables for all functions. It helps to provide a more complete picture of what each function is doing by identifying the local variables it uses.

11. **Type matching analysis for all functions (aaft)**
- Command: `aaft`
- Explanation: This command performs type matching analysis for all functions, attempting to infer and propagate type information throughout the binary. It helps to understand the data types used in the functions, improving the overall analysis accuracy.

12. **Propagate noreturn information (aanr)**
- Command: `aanr`
- Explanation: This command propagates noreturn information, which identifies functions that do not return to their caller (e.g., exit functions). It helps in understanding the control flow, particularly identifying termination points in the code.

13. **Use -AA or aaaa to perform additional experimental analysis**
- Command: `-AA` or `aaaa`
- Explanation: This suggests running more comprehensive and experimental analyses. These commands perform deeper and more extensive analyses, which might provide additional insights but can also take more time and resources.

14. **Scanning for strings constructed in code (/azs)**
- Command: `/azs`
- Explanation: This command scans for strings that are constructed in the code, rather than static strings. It helps to find dynamically generated strings, which can be crucial for understanding runtime behavior, such as command-and-control server URLs or decryption keys.

15. **Finding function preludes (aap)**
- Command: `aap`
- Explanation: This command identifies function preludes, which are the initial instructions of functions. It helps in understanding the function prologues and setting up the analysis for the function bodies.

16. **Enable anal.types.constraint for experimental type propagation**
- Command: `anal.types.constraint=true`
- Explanation: This enables experimental type propagation based on constraints. It aims to improve type inference by using additional constraints and information.

Each of these steps contributes to a thorough analysis of the malware binary. By examining imports, entry points, symbols, function arguments, local variables, function calls, and more, the `reverse_engineer.py` script provides a comprehensive understanding of the malware's structure and behavior. The generated report can then be used to identify potential malicious actions, understand how the malware operates, and develop strategies to mitigate its impact.
